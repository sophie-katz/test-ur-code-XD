{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#test-ur-code-xd-3","title":"test ur code XD :3","text":"<p>GitHub repository | crates.io | docs.rs</p> <p>test ur code XD is a Rust crate that tries to improve testing with a more full-featured framework. It makes tests more readable with better assertions and with more readable errors.</p> <p> </p> Example assertion <p> </p> A string diff assertion"},{"location":"#features","title":"Features","text":""},{"location":"#more-assertions","title":"More assertions","text":"<ul> <li>Floating-point assertions</li> <li>String assertions</li> <li>Panic assertions</li> <li>Output assertions for <code>stdout</code> and <code>stderr</code></li> <li>Filesystem assertions</li> </ul>"},{"location":"#parameterized-tests","title":"Parameterized tests","text":"<pre><code>#[test_with_parameter_values(\n    x = [5, 6, 7],\n    y = [1, 2])\n]\nfn example(x: i32, y: i32) {\n// This will permute the values and automatically run all of these cases:\n//   x == 5, y == 1\n//   x == 5, y == 2\n//   x == 6, y == 1\n//   x == 6, y == 2\n//   x == 7, y == 1\n//   x == 7, y == 2\n}\n</code></pre>"},{"location":"#comparison-to-other-crates","title":"Comparison to other crates","text":"Category test ur code XD Built-in pretty_assertions similar-asserts test-case rstest NTest Pretty assertions \u2714 \u2714 \u2714 Floating-point assertions \u2714 \u2714 Diffing assertions \u2714 \u2714 \u2714 Panic assertions \u2714 \u2714 Output assertions \u2714 Filesystem testing \u2714 Parameterized tests \u2714 \u2714 \u2714 Test permutation \u2714 \u2714 \u2714 Fixtures \u2714"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#getting-started","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>Add this to your <code>Cargo.toml</code>:</p> <pre><code>[dev-dependencies]\ntest-ur-code-xd = \"0.1.0\"\n</code></pre>"},{"location":"getting-started/#usage","title":"Usage","text":"<p>Then, add <code>use test_ur_code_xd::*;</code> to your tests:</p> <pre><code>#[cfg(test)]\nmod tests {\nuse test_ur_code_xd::*;\n#[test]\nfn example() {\n// ...\n\nassert_str_eq!(hello_world, \"hello, world\");\n\n// ...\n}\n}\n</code></pre> <p>This will give you access to the assertions and to the test annotations.</p>"},{"location":"assertions/arithmetic/","title":"Arithmetic","text":""},{"location":"assertions/arithmetic/#arithmetic-assertions","title":"Arithmetic assertions","text":"<p>Arithmetic assertions are those that compare two values together.</p>"},{"location":"assertions/arithmetic/#equality","title":"Equality","text":"<p>These assertions compare values that implement the <code>PartialEq</code> trait:</p> <pre><code>// Ensure that the values are equal\nassert_eq!(x, y);\n\n// Ensure that the values are inequal\nassert_ne!(x, y);\n</code></pre>"},{"location":"assertions/arithmetic/#ordering","title":"Ordering","text":"<p>These assertions compare values that implement the <code>PartialOrd</code> trait:</p> <pre><code>// Ensure that x is less than y\nassert_lt!(x, y);\n\n// Ensure that x is less than or equal to y\nassert_le!(x, y);\n\n// Ensure that x is greater than y\nassert_gt!(x, y);\n\n// Ensure that x is greater than or equal to y\nassert_ge!(x, y);\n</code></pre>"},{"location":"assertions/arithmetic/#details-advanced","title":"Details (advanced)","text":"TraitsPanic conditions <p>The two values do not have to be of the same type. If the first value is of type <code>T</code> and the second of type <code>U</code>, then the following traits must be implemented:</p> <pre><code>// for the equality assertions to work\nimpl PartialEq&lt;U&gt; for T { ... }\n\n// for the order assertions to work\nimpl PartialOrd&lt;U&gt; for T { ... }\n</code></pre> <p>Both types, additionally, must implement the <code>Debug</code> trait.</p> Assertion Panic condition <code>assert_eq</code> <code>!x.eq(y)</code> <code>assert_ne</code> <code>!x.ne(y)</code> <code>assert_lt</code> <code>!x.lt(y)</code> <code>assert_le</code> <code>!x.le(y)</code> <code>assert_gt</code> <code>!x.gt(y)</code> <code>assert_ge</code> <code>!x.ge(y)</code>"},{"location":"assertions/boolean/","title":"Boolean","text":""},{"location":"assertions/boolean/#boolean-assertions","title":"Boolean assertions","text":"<p>There are two boolean assertions:</p> <pre><code>// Ensure that value is true\nassert!(value);\n\n// Ensure that value is false\nassert_not!(value);\n</code></pre> <p>They both take a single true/false argument.</p>"},{"location":"assertions/boolean/#details-advanced","title":"Details (advanced)","text":"TypePanic conditions <p>The values must be of type <code>bool</code>.</p> Assertion Panic condition <code>assert</code> <code>!value</code> <code>assert_not</code> <code>value</code>"},{"location":"assertions/configuring-assertions/","title":"Configuring assertions","text":""},{"location":"assertions/configuring-assertions/#configuring-assertions","title":"Configuring assertions","text":"<p>All assertions have some optional keyword arguments that you can pass in to configure their behavior.</p>"},{"location":"assertions/configuring-assertions/#negation","title":"Negation","text":"<p>Add in the <code>negate = true</code> argument to make the assertion have the opposite of its normal behavior. For example:</p> <pre><code>assert_str_contains!(\"hello, world\", \"asdf\", negate = true);\n</code></pre> <p>This ensures that <code>\"hello, world\"</code> does not contain <code>\"asdf\"</code>.</p>"},{"location":"assertions/configuring-assertions/#descriptions","title":"Descriptions","text":"<p>You can add a description to an assertion by passing in the <code>description = &lt;message&gt;</code> argument. For example:</p> <pre><code>let x = 1.0;\nlet y = 1.05;\n\nassert_le!(\n(x - y).abs(),\n0.1,\ndescription = \"x should be within 0.1 of y\"\n);\n</code></pre> <p>You can also add formatting with the <code>description_owned = &lt;message&gt;</code> argument:</p> <pre><code>const THRESHOLD: f32 = 0.1;\n\nlet x = 1.0;\nlet y = 1.05;\n\nassert_le!(\n(x - y).abs(),\nTHRESHOLD,\ndescription_owned = format!(\"x should be within {} of y\", THRESHOLD)\n);\n</code></pre> <p><code>description</code> accepts as <code>&amp;str</code> value while <code>description_owned</code> accepts a <code>String</code> value.</p>"},{"location":"assertions/custom/","title":"Custom","text":""},{"location":"assertions/custom/#custom-assertions","title":"Custom assertions","text":"<p>You can make custom assertions by using the <code>assert_custom!(...)</code> macro. Let us look at an example:</p> <pre><code>// Instead of this:\nlet x = 3 + 5;\nlet y = 8;\nassert_eq!(x, y);\n\n// We can write this:\nassert_custom!(\n\"lhs == rhs\",\nx == y,\n|panic_message_builder| {\npanic_message_builder\n.with_argument(\"lhs\", \"x\", &amp;x)\n.with_argument(\"rhs\", \"y\", &amp;y)\n}\n)\n</code></pre> <p>Let's break it apart. There are three arguments to <code>assert_custom!(...)</code>:</p> <ul> <li><code>\"lhs == rhs\"</code> - This is the assertion failure message, a description of what the assertion is trying to check for.</li> <li><code>x == y</code> - A boolean expression that is the assertion predicate. When this is <code>true</code>, the assertion passes. When it is <code>false</code>, the assertion panics.</li> <li><code>|panic_message_builder| { ... }</code> - A closure that configures the assertion's panic message to display detailed information about the assertion's arguments.</li> </ul> <p>This allows you to make an assertion with any predicate and print any variables that are relevant.</p>"},{"location":"assertions/custom/#details-advanced","title":"Details (advanced)","text":"TraitsPanic conditions <p>The predicate expression must be of type <code>bool</code>.</p> <p>Any arguments must implement the <code>Debug</code> trait.</p> Assertion Panic condition <code>assert_custom</code> <code>!predicate</code>"},{"location":"assertions/filesystem/","title":"Filesystem","text":""},{"location":"assertions/filesystem/#filesystem-assertions","title":"Filesystem assertions","text":"<p>Filesystem assertions check properties of files and directories.</p>"},{"location":"assertions/filesystem/#paths","title":"Paths","text":"<p>These assertions check the properties of specific paths:</p> <pre><code>// Ensure that the path exists\nassert_path_exists!(\"some_path\");\n\n// Ensure that the path exists and is a file\nassert_path_is_file!(\"some_file\");\n\n// Ensure that the path exists and is a symlink\nassert_path_is_symlink!(\"some_symlink\");\n\n// Ensure that the path exists and is a directory\nassert_path_is_dir!(\"some_dir\");\n\n// Ensure that the path is relative\nassert_path_is_relative!(\"some_path\");\n\n// Ensure that the path is absolute\nassert_path_is_absolute!(\"/some_path\");\n\n// Ensure that the first path is prefixed by the second\nassert_path_starts_with!(\"a/b/c\", \"a\");\n\n// Ensure that the first path is suffixed by the second\nassert_path_ends_with!(\"a/b/c\", \"b/c\");\n</code></pre>"},{"location":"assertions/filesystem/#file-text","title":"File text","text":"<p>There is an assertion to check the contents of a file:</p> <pre><code>assert_file_text!(\n\"hello_world.txt\",\non_text = |text| {\nassert_eq!(\"hello, world\");\n}\n);\n</code></pre> <p>Instead of directly making an assertion on the file contents, it accept a closure. The closure's single argument is the file's contents as a <code>String</code>.</p> <p>Warning</p> <p>This will read the whole file into memory at once. This is fine for smaller files but beware of running this for very large files!</p>"},{"location":"assertions/filesystem/#details-advanced","title":"Details (advanced)","text":"TraitsPanic conditions <p>All path arguments for these asserts do not have to be a particular path type, but must implement the <code>AsRef&lt;Path&gt;</code> trait.</p> Assertion Panic condition <code>assert_path_exists</code> <code>!path.as_ref().exists()</code> <code>assert_path_is_file</code> <code>!path.as_ref().is_file()</code> <code>assert_path_is_symlink</code> <code>!path.as_ref().is_symlink()</code> <code>assert_path_is_dir</code> <code>!path.as_ref().is_dir()</code> <code>assert_path_is_relative</code> <code>!path.as_ref().is_relative()</code> <code>assert_path_is_absolute</code> <code>!path.as_ref().is_absolute()</code> <code>assert_path_is_starts_with</code> <code>!path.as_ref().starts_with(prefix.as_ref())</code> <code>assert_path_is_ends_with</code> <code>!path.as_ref().ends_with(suffix.as_ref())</code>"},{"location":"assertions/float/","title":"Float","text":""},{"location":"assertions/float/#float-assertions","title":"Float assertions","text":"<p>Testing with floats is deceptively complicated. Arithmetic assertions can work with floats just fine, but they do not account for floating-point error in calculations. For example, this assertion will fail:</p> <pre><code>assert_eq!(\n0.15 + 0.15 + 0.15,\n0.1 + 0.1 + 0.25\n);\n</code></pre> <p>To explain why, we need to understand a bit of background about floating-point comparison. This excellent article by Bruce Dawson goes into much more detail.</p> <p>Warning</p> <p>There's a lot of explanation before this document gets to the actual assertions. This is intentional.</p> <p>test ur code XD handles floating-point testing in a much more detailed manner than many other testing frameworks. It requires a bit of background to understand why.</p> <p>The example above taken from the excellent <code>float_cmp</code> crate. test ur code XD builds a bit more functionality on top of it.</p>"},{"location":"assertions/float/#floating-point-comparison-is-complicated","title":"Floating-point comparison is complicated","text":"<p>Floating-point numbers take up 32 or 64 bits on most architectures. This provides a lot of precision, but not infinite precision. For example, 0.1 cannot be represented exactly using 32 bits. Instead, it is represented as 0.10000000149. The next smallest floating-point number possible in 32-bits is 0.0999999940395.</p> <p>ULP is short for Unit in Last Place. It is the distance between a given floating-point value and the next one possible. See this article for more detail. For example, there is 1 ULP between 0.0999999940395 and 0.10000000149 because they are neighbors.</p>"},{"location":"assertions/float/#epsilons","title":"Epsilons","text":"<p>Systems provide floating point epsilons to help with floating-point comparisons. In rust they are defined as <code>f32::EPSILON</code> and <code>f64::EPSILON</code>. They are the difference between <code>1.0</code> and the next highest floating-point value.</p>"},{"location":"assertions/float/#most-floating-point-testing-is-bad","title":"Most floating-point testing is bad","text":"<p>Two very common methods of testing with floating-point values have major issues.</p>"},{"location":"assertions/float/#epsilons-alone-are-not-enough","title":"Epsilons alone are not enough","text":"<p>A lot of floating-point testing is done using floating-point epsilons. It looks like this:</p> <pre><code>abs(x - y) &lt;= epsilon\n</code></pre> <p>But there's a problem. When <code>x</code> and <code>y</code> are between 1.0 and 2.0, an <code>f32::EPSILON</code> comparison means that the two values are within 1 ULP. However 1 ULP at 1,000,000 is 0.0625. This epsilon is way too small to be useful at that range.</p>"},{"location":"assertions/float/#ulps-alone-are-not-enough","title":"ULPs alone are not enough","text":"<p>ULPs can also be used directly for comparison, which is what the Google Test Framework does in C++. It says that if two floating-point values are within 4 ULPs, then they are close enough to equal. The problem is that in every floating-point operation there is a possible error. This error can accumulate over multiple operations, and easily get over 4 ULPs.</p> <p>Moreover, near zero one ULP is an incredibly small value. The next highest floating-point value after 0.0 is 1.40129846432e-45. This is way smaller than <code>f32::EPSILON</code> and implies much more precision than most floating-point calculations need. Near zero, 1 ULP is much too precise.</p>"},{"location":"assertions/float/#testing-that-takes-this-into-account","title":"Testing that takes this into account","text":"<p>There are two potential ways to compare floating-point numbers while taking this into account. </p>"},{"location":"assertions/float/#relative-epsilons","title":"Relative epsilons","text":"<p><code>f32::EPSILON</code> and <code>f64::EPSILON</code> are 1 ULP between 1.0 and 2.0, but they can be extended to be applicable to numbers outside that range. Multiply them by the larger magnitude of the two numbers to get a relative epsilon. This relative epsilon will have approximately the same precision at different magnitudes.</p> <p>This still breaks down when comparing numbers near zero, though. Near zero, an absolute epsilon can be used. This is a fixed value which represents the real precision needed for the calculation. If your calculation needs to be accurate to within 1e-6, then use 1e-6 as the absolute epsilon.</p>"},{"location":"assertions/float/#ulps-with-epsilon-near-zero","title":"ULPs with epsilon near zero","text":"<p>ULPs by definition have precision that is relative to the magnitude of the numbers being compared. This is good, but it still breaks down near zero. The same absolute epsilon can be used near zero as for relative epsilon comparisons.</p>"},{"location":"assertions/float/#when-to-use-relative-epsilon-vs-ulps","title":"When to use relative epsilon vs ULPs","text":"<p>Unfortunately, there is no right answer. Relative epsilons tend to make a bit more sense when you care more about real numbers, while ULPs tend to make more sense mean dealing with the details of floating-point operations.</p>"},{"location":"assertions/float/#special-floating-point-values","title":"Special floating-point values","text":"<p>The special floating point values we care about are:</p> <ul> <li>Positive infinity</li> <li>Negative infinity</li> <li>NaN</li> <li>Negative zero</li> </ul> <p>These values can be compared using separate logic to the rest of the numbers:</p> <ul> <li>Positive infinity is only equal to positive infinity</li> <li>Negative infinity is only equal to negative infinity</li> <li>NaN is only equal to NaN</li> <li>Negative zero is equivalent to positive zero for the purposes of comparison</li> </ul>"},{"location":"assertions/float/#assertions","title":"Assertions","text":"<p>test ur code XD provides assertions that follow the above guidelines. Let us take the assertion <code>assert_f32_eq!(...)</code> as an initial example for relative epsilon comparison:</p> <pre><code>assert_f32_eq!(\nx,\ny,\nrelative_epsilon = f32::EPSILON,\nepsilon_near_zero = 1e-6\n);\n</code></pre> <p>The assertion has these keyword arguments:</p> <ul> <li><code>relative_epsilon = f32::EPSILON</code> means that the relative epsilon used for comparison is <code>f32::EPSILON</code>.</li> <li><code>epsilon_near_zero = 1e-6</code> is the fixed epsilon that is used when <code>x</code> and <code>y</code> are near zero. This means that the comparison is guaranteed to within <code>1e-6</code> precision. You can set it to 0.0 to disable near zero comparison handling.</li> </ul> <p>Info</p> <p>These arguments apply to every floating-point assertion in test ur code XD.</p> <p>There is no default value for either argument because these values will have to change for different comparisons depending on the calculation and the needs of the testing.</p> <ul> <li><code>relative_epsilon</code> will commonly be something like <code>4 * f32::EPSILON</code> to account for more error in the calculation.</li> <li><code>epsilon_near_zero</code> is the absolute guaranteed precision and will need to change depending on the needs of the testing.</li> </ul>"},{"location":"assertions/float/#with-ulps","title":"With ULPs","text":"<p>You can also write this assertion in terms of ULPs:</p> <pre><code>assert_f32_eq!(x, y, ulps = 1, epsilon_near_zero = 1e-6);\n</code></pre> <p>The argument <code>ulps = 1</code> means that the calculation is guaranteed to be correct within 1 ULP.</p>"},{"location":"assertions/float/#different-types-of-comparisons","title":"Different types of comparisons","text":"<p>test ur code XD has these assertion macros for doing different comparisons with floats:</p> <pre><code>// Ensure that x and y are equal accounting for floating-point error\nassert_f32_eq!(x, y, ...);\n\n// Ensure that x and y are inequal accounting for floating-point error\nassert_f32_ne!(x, y, ...);\n\n// Ensure that x is less than or equal to y accounting for\n// floating-point error\nassert_f32_le!(x, y, ...);\n\n// Ensure that x is greater than or equal to y accounting for\n// floating-point error\nassert_f32_ge!(x, y, ...);\n</code></pre> <p>There are also equivalent macros for dealing with <code>f64</code> values:</p> <pre><code>assert_f64_eq!(x, y, ...);\nassert_f64_ne!(x, y, ...);\nassert_f64_le!(x, y, ...);\nassert_f64_ge!(x, y, ...);\n</code></pre> <p>They all use the same arguments.</p>"},{"location":"assertions/output/","title":"Output","text":""},{"location":"assertions/output/#output-assertion","title":"Output assertion","text":"<p>The output assertion checks for <code>stdout</code> and <code>stderr</code> output from specific pieces of code:</p> <pre><code>assert_outputs!(\n|| {\nprintln!(\"hello, world\");\n},\non_stdout = |stdout| {\nassert_eq!(stdout, \"hello, world\\n\");\n}\n);\n</code></pre> <p>You can use <code>on_stdout = &lt;closure&gt;</code>, <code>on_stderr = &lt;closure&gt;</code>, or both to check the output streams.</p> <p>Warning</p> <p>To use this assertion you need to configure Cargo as described below.</p>"},{"location":"assertions/output/#avoiding-cargo-issues","title":"Avoiding Cargo issues","text":"<p>To use this assertion, you must create or modify the <code>.cargo/config.toml</code> file. Add this to it:</p> <pre><code>[env]\nRUST_TEST_NOCAPTURE = \"1\"\nRUST_TEST_THREADS   = \"1\"\n</code></pre> <p>By default, <code>cargo test</code> will capture output and also run tests in parallel. These both cause issues for <code>assert_outputs!(...)</code>.</p> <ul> <li> <p>Cargo's output capturing means that <code>stdout</code> and <code>stderr</code> will be empty when the code actually runs. This means that <code>assert_outputs!(...)</code> becomes useless.</p> </li> <li> <p>Although the assertion is thread safe, it cannot stop other threads from using <code>stdout</code> and <code>stderr</code>. This means that <code>assert_outputs!(...)</code> becomes unreliable.</p> </li> </ul>"},{"location":"assertions/panic/","title":"Panic","text":""},{"location":"assertions/panic/#panic-assertion","title":"Panic assertion","text":"<p>The panic assertion checks if a specific piece of code panics:</p> <pre><code>// Ensure that the code panics\nassert_panics!(\n|| {\npanic!();\n}\n);\n\n// Ensure that the code panics with a specific message\nassert_panics!(\n|| {\npanic!(\"hello, world\");\n},\non_message = |message| {\nassert_eq!(message, \"hello, world\");\n}\n);\n</code></pre> <p>The second call to <code>assert_panics!</code> takes an <code>on_message</code> argument. This argument is a closure that takes a single argument of type <code>String</code> representing the panic message.</p>"},{"location":"assertions/panic/#why-not-should_panic","title":"Why not <code>#[should_panic]</code>?","text":"<p>Rust has a built-in attribute called <code>#[should_panic]</code> that can be used to check if a unit test will panic:</p> <pre><code>#[test]\n#[should_panic]\nfn unit_test() {\npanic!();\n\n// Code here will not run\n}\n</code></pre> <p>There's no reason not to use this, but <code>assert_panics!(...)</code> provides a bit more granularity and can allow code to continue after the panic:</p> <pre><code>#[test]\nfn unit_test() {\nassert_panics!(\n|| {\npanic!();\n}\n);\n\n// This code will still run\n}\n</code></pre>"},{"location":"assertions/string/","title":"String","text":""},{"location":"assertions/string/#string-assertions","title":"String assertions","text":"<p>String assertions operate on string types:</p> <pre><code>// Compare two strings and diff the results\nassert_str_eq!(\"hello, world\", \"hello\");\n\n// Ensure that the second string is contained within the first\nassert_str_contains!(\"hello, world\", \"hello\");\n\n// Ensure that the first string starts with the second \nassert_str_starts_with!(\"hello, world\", \"hello\");\n\n// Ensure that the first string ends with the second\nassert_str_ends_with!(\"hello, world\", \"world\");\n\n// Ensure that the first string matches the second regex\nassert_str_matches!(\"hello, world\", \"[a-z, ]+\");\n</code></pre> <p>Regular expressions for <code>assert_str_matches</code> follow the rules for the <code>regex</code> crate.</p>"},{"location":"assertions/string/#details-advanced","title":"Details (advanced)","text":"TraitsPanic conditions <p>Both arguments for all these asserts do not have to be a particular string type, but must implement the <code>AsRef&lt;str&gt;</code> trait.</p> Assertion Panic condition <code>assert_str_contains</code> <code>!x.as_ref().contains(y.as_ref())</code> <code>assert_str_starts_with</code> <code>!x.as_ref().starts_with(y.as_ref())</code> <code>assert_str_ends_with</code> <code>!x.as_ref().ends_with(y.as_ref())</code> <code>assert_str_matches</code> <code>Regex::new(y.as_ref())?.is_match(x.as_ref())</code>"},{"location":"extending/recommended-crates/","title":"Recommended crates","text":""},{"location":"extending/recommended-crates/#recommended-crates","title":"Recommended crates","text":"<p>There are a lot of testing crates in Rust that provide functionality that test ur code XD does not. Here are some recommendations:</p>"},{"location":"extending/recommended-crates/#utilities","title":"Utilities","text":"Crate Description Nextest A new, faster test runner for Rust Static assertions Compile-time assertions for Rust Fail Fail point implementation for Rust <code>partial-io</code> Helpers for testing I/O behavior with partial, interrupted and blocking reads and writes <code>assert_cmd</code> Easy command initialization and assertions"},{"location":"extending/recommended-crates/#test-cases","title":"Test cases","text":"Crate Description <code>serial_test</code> Allows for the creation of serialised Rust tests <code>rstest</code> Fixture-based test framework for Rust Datatest Crate for supporting data-driven tests"},{"location":"extending/recommended-crates/#fuzzing-and-property-testing","title":"Fuzzing and property testing","text":"Crate Description Arbitrary Trait for generating structured data from arbitrary, unstructured input Proptest Property testing framework inspired by the Hypothesis framework for Python Kani Bit-precise model checker for Rust Bolero Fuzz and property testing front-end for Rust"},{"location":"extending/recommended-crates/#mocking","title":"Mocking","text":"Crate Description Mockall Powerful mock object library for Rust"},{"location":"extending/writing-your-own-assertions/","title":"Writing your own assertions","text":""},{"location":"extending/writing-your-own-assertions/#writing-your-own-assertions","title":"Writing your own assertions","text":"<p>This applies both when adding new assertions to this crate or when extending the library in another crate.</p>"},{"location":"extending/writing-your-own-assertions/#implement-the-predicate","title":"Implement the predicate","text":"<p>First write a function that represents the assertion predicate. It will take the inputs as arguments and then return a boolean value. If it returns <code>true</code>, the assertion will pass. If it returns a <code>false</code>, the assertion will fail and cause a panic. It will look something like this:</p> Non-copyable typesCopyable types <p>Unless the inputs implement the <code>Copy</code> trait, make sure to pass them in by reference:</p> <pre><code>#[doc(hidden)]\npub fn my_assertion_impl(\ninput0: &amp;InputType0,\ninput1: &amp;InputType1,\n/* ... */\n) -&gt; bool {\n/* ... */\n}\n</code></pre> <p>If the inputs implement the <code>Copy</code> trait, you can pass them in by value:</p> <pre><code>#[doc(hidden)]\npub fn my_assertion_impl(\ninput0: InputType0,\ninput1: InputType1,\n/* ... */\n) -&gt; bool {\n/* ... */\n}\n</code></pre> <p>It has to be public so that the macro can access it, but since it is only for internal use we mark it <code>#[doc(hidden)]</code>.</p>"},{"location":"extending/writing-your-own-assertions/#example","title":"Example","text":"<p>Let's reimplement the <code>assert_str_contains!(...)</code> macro from this crate as an example. It will be a bit simplified from the actual implementation:</p> <pre><code>#[doc(hidden)]\npub fn assert_str_contains_impl(value: &amp;str, substring: &amp;str) -&gt; bool {\nvalue.contains(substring)\n}\n</code></pre> <p>Now that we have the perdicate, we can put together the macro itself.</p>"},{"location":"extending/writing-your-own-assertions/#declare-the-macro","title":"Declare the macro","text":"<p>Once we have the predicate function, we can wrap it in a macro. This will essentially be a wrapper around <code>assert_custom!(...)</code> macro. It will look something like this:</p> <pre><code>#[macro_export]\nmacro_rules! my_assertion {\n($input0:expr, $input1:expr $(, $keys:ident = $values:expr)* $(,)?) =&gt; {\n::test_ur_code_xd::assert_custom!(\n\"a description of my assertion's predicate\",\n$crate::my_assertion_impl($input0, $input1),\n|panic_message_builder| {\npanic_message_builder\n.with_argument(\"input0\", stringify!($input0), &amp;$input0)\n.with_argument(\"input1\", stringify!($input1), &amp;$input1)\n}\n$(, $keys = $values)*\n)\n}\n}\n</code></pre> <p>This is a lot! Let's break it down.</p>"},{"location":"extending/writing-your-own-assertions/#macro-arguments","title":"Macro arguments","text":"<p>The macro will take the inputs as <code>expr</code> arguments. This means that any Rust expression can be used for the assertion inputs. Then we have some additional argument code:</p> <pre><code>$(, $keys:ident = $values:expr)* $(,)?\n</code></pre> <p>This is to accept any number of <code>&lt;key&gt; = &lt;value&gt;</code> arguments which are used to configure the macro. When you pass <code>negate = true</code> into a macro as an additional argument, it goes through this code.</p>"},{"location":"extending/writing-your-own-assertions/#use-assert_custom","title":"Use <code>assert_custom!(...)</code>","text":"<p>Then we have the call to <code>assert_custom!(...)</code>. We pass in all of our custom logic in as the arguments to this macro. This is also the only place where the macro is different between assertions written internally to test ur code XD and outside.</p> <p>Note</p> <p>Macros written inside this crate will call this macro like <code>$crate::assert_custom(...)</code> while macros outside will write this <code>::test_ur_code_xd::assert_custom(...)</code>.</p>"},{"location":"extending/writing-your-own-assertions/#predicate-description","title":"Predicate description","text":"<p>The first parameter is a description of the predicate:</p> <pre><code>\"a description of my assertion's predicate\"\n</code></pre> <p>This is used in the first line of the panic message. For example, the description for <code>assert_str_contains!(...)</code> is <code>\"value contains substring\"</code>. It is important that the inputs are named here so that the panic message's inputs can easily be understood.</p>"},{"location":"extending/writing-your-own-assertions/#call-the-predicate-function","title":"Call the predicate function","text":"<p>The second parameter is a call to our predicate function:</p> Non-copyable typesCopyable types <p>Unless the inputs implement the <code>Copy</code> trait, make sure to pass them in by reference:</p> <pre><code>$crate::my_assertion_impl(&amp;$input0, &amp;$input1)\n</code></pre> <p>If the inputs implement the <code>Copy</code> trait, you can pass them in by value:</p> <pre><code>$crate::my_assertion_impl($input0, $input1)\n</code></pre>"},{"location":"extending/writing-your-own-assertions/#build-the-panic-message","title":"Build the panic message","text":"<p>The third parameter is a closure which takes a <code>PanicMessageBuilder</code> and returns the same instance. This is used to configure the panic message, usually to add debug information about the inputs:</p> <pre><code>|panic_message_builder| {\npanic_message_builder\n.with_argument(\"input0\", stringify!($input0), &amp;$input0)\n.with_argument(\"input1\", stringify!($input1), &amp;$input1)\n}\n</code></pre>"},{"location":"extending/writing-your-own-assertions/#forward-keyword-arguments","title":"Forward keyword arguments","text":"<p>After the three arguments, we need to pass in any <code>&lt;key&gt; = &lt;value&gt;</code> arguments that we want to forward from our macro invocation:</p> <pre><code>$(, $keys = $values)*\n</code></pre> <p>Warning</p> <p>Make sure not to put a comma before this! It will cause hard to debug compile-time errors. Make sure it's written like this:</p> <pre><code>// ...\n|panic_message_builder| {\npanic_message_builder\n.with_argument(\"input0\", stringify!($input0), &amp;$input0)\n.with_argument(\"input1\", stringify!($input1), &amp;$input1)\n} // \u2190 no comma here\n$(, $keys = $values)*\n// ...\n</code></pre> <p>Now your assertion should be functional!</p>"},{"location":"extending/writing-your-own-assertions/#example_1","title":"Example","text":"<p>Here's our simplified implementation of the <code>assert_str_contains!(...)</code> macro to use as an example:</p> <pre><code>#[doc(hidden)]\npub fn assert_str_contains_impl(value: &amp;str, substring: &amp;str) -&gt; bool {\nvalue.contains(substring)\n}\n\n#[macro_export]\nmacro_rules! assert_str_contains {\n($value:expr, $substring:expr $(, $keys:ident = $values:expr)* $(,)?) =&gt; {\n::test_ur_code_xd::assert_custom!(\n\"value contains substring\",\n::test_ur_code_xd::assertions::string_assertions::assert_str_contains_impl(\n$value,\n$substring\n),\n|panic_message_builder| {\npanic_message_builder\n.with_argument(\"value\", stringify!($value), &amp;$value)\n.with_argument(\"substring\", stringify!($substring), &amp;$substring)\n}\n$(, $keys = $values)*\n)\n};\n}\n</code></pre> <p>Then you can invoke it like this:</p> <pre><code>assert_str_contains!(\"hello, world\", \"world\");\nassert_str_contains!(\"hello, world\", \"asdf\", negate = true);\n</code></pre>"},{"location":"extending/writing-your-own-assertions/#writing-your-own-assertion-wrapper-macros-advanced","title":"Writing your own assertion wrapper macros (advanced)","text":"<p>Some assertion macros do not explicitly make an assertion based on a predicate, but instead accept a closure of other assertions. For example <code>assert_outputs!(...)</code> captures output but then relies on closures to make assertions about the captured output:</p> <pre><code>assert_outputs!(\n|| {\nprintln!(\"some text\");\n},\non_stdout = |stdout| {\nassert_eq!(stdout, \"some text\\n\");\n}\n);\n</code></pre> <p>The first step towards writing a macro like this is to, again, write an implementation function. It will look something like this:</p> <pre><code>#[doc(hidden)]\npub fn my_assertion_wrapper_impl&lt;\nActionType: FnOnce(),\nResultCallbackType: FnOnce(ResultType0),\n&gt;(\naction: ActionType,\nresult_callback: ResultCallbackType,\n) {\n// ...\n\naction();\n\n// ...\n\nresult_callback(result);\n}\n</code></pre> <p>Then write a macro to wrap this:</p> <pre><code>#[macro_export]\nmacro_rules! my_assertion_wrapper {\n(\n$action:expr,\non_result = $on_result:expr\n) =&gt; {\n$crate::my_assertion_wrapper_impl(\n$action,\n$on_result,\n)\n};\n}\n</code></pre> <p>Ironically, this is simpler than implementing a new assertion with a predicate.</p>"},{"location":"extending/writing-your-own-assertions/#example_2","title":"Example","text":"<p>For a real world example of this, look at how a simplified version of <code>assert_panics!(...)</code> is implemented. Here is the predicate function:</p> <pre><code>#[doc(hidden)]\npub fn assert_panics_impl&lt;\nActionType: FnOnce() + UnwindSafe,\nMessageCallbackType: FnOnce(String),\n&gt;(\naction: ActionType,\non_message: MessageCallbackType,\n) {\n// If the action panics:\nif let Err(error) = panic::catch_unwind(AssertUnwindSafe(action)) {\n// Check the message\non_message(panic_message::panic_message(&amp;error).to_owned());\n} else {\n// Otherwise, fail the assertion\nPanicMessageBuilder::new(\"action panics\", Location::caller()).panic();\n}\n}\n</code></pre> <p>And then here is a simplified version of the macro:</p> <pre><code>#[macro_export]\nmacro_rules! assert_panics {\n($action:expr, on_message = $on_message:expr) =&gt; {\n$crate::assert_panics_impl(\n$action,\n$on_message,\n)\n};\n}\n</code></pre>"},{"location":"tests/parameterized-tests/","title":"Parameterized tests","text":""},{"location":"tests/parameterized-tests/#parameterized-tests","title":"Parameterized tests","text":"<p>test ur code XD provides an attribute to parameterize tests:</p> <pre><code>#[test_with_parameter_values(\n    x = [5, 6, 7],\n    y = [1, 2])\n]\nfn example(x: i32, y: i32) {\nassert!(x + y &gt; 0);\n}\n</code></pre> <p>This will permute the values of <code>x</code> and <code>y</code> and run the test for each permutation. In this case, the test will run 6 times:</p> <code>x</code> <code>y</code> 5 1 5 2 6 1 6 2 7 1 7 2 <p>Warning</p> <p>The values must be array literals. Vectors or other dynamically generated values are not supported.</p>"}]}